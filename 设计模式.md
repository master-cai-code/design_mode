 ## 关于UML图的解释
       +：public  #：protected   -：private
     1.继承（三角形箭头的实线）由子类指向父类
     2.实现（三角箭头的虚线） 由实现类指向父接口
     3.关联（普通箭头的实线） 【1:1   1：n   m：n】      一个类持有另一个类的对象
     4.依赖 （普通箭头的虚线）   一个类使用另一个类（人用物）    局部变量或参数
     5.聚合 （空心菱形加实线）   雁群和雁
     6.组合  （实心菱形加实线）  人和手
     
## 关于设计模式的理解     
     把封装、继承、多态玩出花，用类和对象模拟真实世界
 
# 建造者模式
##   1.一句话： 一个复杂对象由多个子部件组合而成
##   2.生活举例： 电脑由CPU、内存、显卡、磁盘等组成
##   3.实施过程：
        1.指挥者指挥建造者
        2.建造者建造复杂商品
          
# 原型模式
##  1.一句话： 创建一个和原型对象相同的对象
##  2.生活举例： 复制出多个相同的东西
##  3.实施过程： 实现浅克隆（成员对象不克隆）
           1. 克隆类实现cloneable接口
           2.重写clone（）方法
           3.调用克隆类对象的clone（）方法，向下转型得到  克隆对象
           
 
 # 适配器模式
 ## 1.一句话：两个对象不兼容，需要第三者适配（调和）；将一个接口转换成客户需要的另一个接口
 ## 2.生活举例： 直流电的电脑接交流电时需要一个适配器
 ## 3.实施过程：  一个接口组合另一个接口......（改变原接口的数据，方法操作等来适应客户接口）
 
 
 
 # 解释器模式
 ## 1.一句话： 定义一种语言的文法表示，用解析器解释句子（类似编译原理...）
 
 
 
 
 # 装饰者模式        
 ## 1.一句话：不改变原对象的结构，动态的添加一些额外功能      ；  物体 + 物体 = 物体
 ## 2.生活举例：为玻璃杯塞泡沫，让其具有一定的防摔能力，再[玻璃杯+泡沫]整体包一层花盒子，让整体变得好看...还能继续包装
 ## 3.实施代码：
        1. 被装饰者和装饰者都实现一个父接口
        2. 装饰者里面还有一个这样的父接口对象（可以用来接收没被装饰和已经被装饰的对象）
        3. 具体的装饰者不断向上调用父类同名方法进行“累加”得到最终结果
 
 
 
 # 代理模式
 ## 1.一句话：利用新建的代理对象，动态的增强一个对象的方法
 ## 2.生活举例：找工作通过中介来找（中介帮你搜找到有面试需求的公司）
 ## 3.实施代码：
       1. 一个类实现InvocationHandler接口
       2. 重写invoke()方法，在这个方法里面“增强”   （ method.invoke（obj，args）是原有方法 ）
       3. Proxy.newProxyInstance（classloader，interfaces，invocationhandler）得到代理对象
 
 
 # 策略模式
 ## 1.一句话： 完成一件事有多种方法（策略）
 ## 2.生活举例：超市促销可以打折，赠送小礼品，换积分；去浙江可以做飞机、火车、汽车等
 ## 3.实施代码：
          1. 一个总策略接口
          2.不同具体策略各自实现总策略接口，使用类 内置总策略类型变量
          根据多态实现..
 
 
 
 # 模板模式
 
 
 
 
 # 委派模式
    ✘✘✘
 
 
 
 # 桥接模式
 ## 1.一句话： 实现一个东西多个维度的组合
 ## 2.生活举例：一个字既有大小又有颜色，实现不同字体大小和不同颜色的组合（排列组合叭）
 ## 3.实施过程：一个维度里面组合另一个维度
 
 
 # 享元模式
 ## 1.一句话：用一个对象代替其他相同对象，减少创建很多相同对象的开销
 ## 2.生活举例：围棋中的白棋和黑棋，只用创建一个白棋和黑棋，然后复用
 ## 3.实施过程：享元工厂用集合（map或list）管理每个不同种类的一个对象（感觉就是多个单例???）
 
 
 # 观察者模式
 ## 1.一句话：一个对象的行为改变会引起其他对象（一个或多个）的改变   目标对象改变，引起观察者改变
 ## 2.生活举例：老师布置作业，多个学生要接收作业
 ## 3.实施过程：目标类中含有对观察者的操作（添加、删除、通知）
             1.用list集合装观察者对象
             2.利用集合的添加删除操作观察者
             3.通知观察者：采用集合遍历的方式，调用各个观察者的处理方法
  
  
  
 # 单例
 
 
 
 # 工厂
